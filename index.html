<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ink & Blade: Ronin</title>
    <meta name="theme-color" content="#ffffff">
    <meta name="description" content="A tactical monochrome action game.">
    
    <link rel="manifest" href="manifest.json" id="manifest-placeholder">

    <style>
        :root {
            --bg-color: #f0f0f0;
            --ink-color: #1a1a1a;
            --hero-color: #e63946; /* The Red Highlight */
            --ui-font: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
            touch-action: none; /* Prevent browser zooming/scrolling */
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-weight: bold;
            font-size: 1.2rem;
            color: var(--ink-color);
        }

        /* Menus */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(240, 240, 240, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            color: var(--ink-color);
            text-transform: uppercase;
            letter-spacing: 5px;
            border-bottom: 4px solid var(--hero-color);
            display: inline-block;
        }

        p { color: #555; margin-bottom: 2rem; max-width: 300px; line-height: 1.5; }

        button {
            background: var(--ink-color);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: var(--ui-font);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.1s, background 0.2s;
            margin: 10px;
            box-shadow: 4px 4px 0px var(--hero-color);
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px var(--hero-color);
        }

        button.secondary {
            background: transparent;
            color: var(--ink-color);
            border: 2px solid var(--ink-color);
            box-shadow: none;
        }

        /* Sound Toggle */
        #sound-btn {
            pointer-events: auto;
            background: none;
            border: 2px solid var(--ink-color);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: none;
            padding: 0;
        }

        /* Tutorial Hint */
        #tutorial {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <span id="score-display">KILLS: 0</span>
            <button id="sound-btn">ðŸ”Š</button>
        </div>
        <div id="tutorial" class="hidden">DRAG & RELEASE TO SLASH</div>
    </div>

    <div id="start-screen" class="screen">
        <h1>INK & BLADE</h1>
        <p>Tactical Action. <br>Drag to aim. Release to slash. <br>Kill the Ink Blots.</p>
        <button onclick="startGame()">PLAY</button>
        <p style="font-size: 0.8rem; margin-top: 20px;">v1.0.0 | H24 Creationz</p>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="border-color: black;">WASTED</h1>
        <p>SCORE: <span id="final-score">0</span></p>
        <p>HIGH SCORE: <span id="best-score">0</span></p>
        <button onclick="startGame()">RETRY</button>
        <button class="secondary" onclick="showHome()">MENU</button>
    </div>

    <script type="module">
        // Paste Firebase Configuration Here Later
        window.saveScoreToCloud = function(score) {
            console.log("Firebase not configured yet. Score:", score);
        };
    </script>

    <script>
        /** * ENGINE CONFIGURATION 
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
        let score = 0;
        let highScore = localStorage.getItem('ink_blade_highscore') || 0;
        let soundEnabled = true;

        // Audio Context (Lazy load)
        let audioCtx;

        // Resize Handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        /**
         * GAME OBJECTS
         */
        
        // The Hero (Red Dot)
        const player = {
            x: 0, y: 0,
            radius: 12,
            color: '#e63946',
            vx: 0, vy: 0,
            friction: 0.92,
            isMoving: false,
            slashPower: 15
        };

        // Input Handling
        const input = {
            isDragging: false,
            startX: 0, startY: 0,
            currentX: 0, currentY: 0
        };

        // Entity Arrays
        let enemies = [];
        let particles = [];
        let cameraShake = 0;

        /**
         * AUDIO SYSTEM (Procedural - No files needed)
         */
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'slash') {
                // High pitch swoosh
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'hit') {
                // Noise burst for impact
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'die') {
                // Low descending tone
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // Toggle Sound Button
        document.getElementById('sound-btn').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-btn').innerText = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            initAudio(); // Initialize context on first interaction
        });

        /**
         * GAME LOGIC
         */

        function spawnEnemy() {
            // Spawn away from player
            let x, y, dist;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
                dist = Math.hypot(x - player.x, y - player.y);
            } while (dist < 200);

            enemies.push({
                x: x, y: y,
                radius: 15 + Math.random() * 10, // Ink blot variety
                speed: 1 + Math.random() * 1.5, // Random speed
                color: '#1a1a1a'
            });
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 4
                });
            }
        }

        function startGame() {
            initAudio();
            gameState = 'PLAYING';
            score = 0;
            enemies = [];
            particles = [];
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.vx = 0;
            player.vy = 0;
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('tutorial').classList.remove('hidden');
            document.getElementById('score-display').innerText = "KILLS: 0";

            // Initial enemies
            spawnEnemy();
            spawnEnemy();
            spawnEnemy();

            loop();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            playSound('die');
            
            // High Score Logic
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('ink_blade_highscore', highScore);
            }

            // Sync with Firebase (Function call)
            if (window.saveScoreToCloud) {
                window.saveScoreToCloud(score);
            }

            document.getElementById('final-score').innerText = score;
            document.getElementById('best-score').innerText = highScore;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function showHome() {
            gameState = 'MENU';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
        }

        /**
         * MAIN LOOP
         */
        function loop() {
            if (gameState !== 'PLAYING') return;
            requestAnimationFrame(loop);

            // Update Physics
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Screen Shake
            if (cameraShake > 0) {
                ctx.save();
                let dx = (Math.random() - 0.5) * cameraShake;
                let dy = (Math.random() - 0.5) * cameraShake;
                ctx.translate(dx, dy);
                cameraShake *= 0.9; // Decay
                if(cameraShake < 0.5) cameraShake = 0;
            }

            // Draw Aim Line
            if (input.isDragging) {
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                // Calculate aim direction (Opposite to drag)
                let dx = input.startX - input.currentX;
                let dy = input.startY - input.currentY;
                ctx.lineTo(player.x + dx, player.y + dy);
                ctx.strokeStyle = 'rgba(230, 57, 70, 0.4)'; // Faint red line
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Slow Motion Effect
                // We update enemies slower when aiming
            }

            // Update Player
            player.x += player.vx;
            player.y += player.vy;
            player.vx *= player.friction;
            player.vy *= player.friction;

            // Bounce off walls
            if (player.x < 0 || player.x > canvas.width) { player.vx *= -1; player.x = Math.max(0, Math.min(canvas.width, player.x)); }
            if (player.y < 0 || player.y > canvas.height) { player.vy *= -1; player.y = Math.max(0, Math.min(canvas.height, player.y)); }

            player.isMoving = (Math.abs(player.vx) + Math.abs(player.vy)) > 1;

            // Draw Player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();
            // Speed trail
            if (player.isMoving) {
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x - player.vx * 3, player.y - player.vy * 3);
                ctx.strokeStyle = 'rgba(230, 57, 70, 0.5)';
                ctx.lineWidth = player.radius;
                ctx.stroke();
            }

            // Update Enemies
            // "Time moves when you move" mechanic:
            // If player is dragging (aiming), enemies move at 10% speed.
            // If player is moving fast (slashing), enemies move at 10% speed (Bullet time).
            // If player is idle, enemies move at 100% speed.
            
            let timeScale = 1.0;
            if (input.isDragging) timeScale = 0.1; 
            else if (player.isMoving) timeScale = 0.2;

            enemies.forEach((enemy, index) => {
                // Move towards player
                let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemy.x += Math.cos(angle) * enemy.speed * timeScale;
                enemy.y += Math.sin(angle) * enemy.speed * timeScale;

                // Draw Enemy (Ink Blot style)
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                // Scribble effect
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10);
                ctx.stroke();

                // Collision: Player Slashing Enemy
                let dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                
                if (dist < player.radius + enemy.radius) {
                    if (player.isMoving) {
                        // Kill Enemy
                        enemies.splice(index, 1);
                        createParticles(enemy.x, enemy.y, '#1a1a1a', 10);
                        playSound('hit');
                        score++;
                        cameraShake = 5;
                        document.getElementById('score-display').innerText = "KILLS: " + score;
                        
                        // Spawn new enemies progressively
                        if (enemies.length < 3 + (score / 5)) {
                            spawnEnemy();
                            spawnEnemy();
                        }
                    } else {
                        // Player Dies
                        gameOver();
                    }
                }
            });

            // Keep enemy count up
            if (enemies.length === 0) spawnEnemy();

            // Particles
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
                if (p.life <= 0) particles.splice(i, 1);
            });

            if (cameraShake > 0) ctx.restore();
        }

        /**
         * INPUT EVENTS (Mouse & Touch)
         */
        function startInput(x, y) {
            if (gameState !== 'PLAYING') return;
            input.isDragging = true;
            input.startX = x;
            input.startY = y;
            input.currentX = x;
            input.currentY = y;
            document.getElementById('tutorial').classList.add('hidden');
        }

        function moveInput(x, y) {
            if (!input.isDragging) return;
            input.currentX = x;
            input.currentY = y;
        }

        function endInput() {
            if (!input.isDragging) return;
            input.isDragging = false;

            // Calculate launch vector
            let dx = input.startX - input.currentX;
            let dy = input.startY - input.currentY;
            
            // Cap max speed
            let mag = Math.hypot(dx, dy);
            if (mag > 10) {
                let force = Math.min(mag, 150) / 10; // Power scaling
                let angle = Math.atan2(dy, dx);
                
                player.vx = Math.cos(angle) * force * 1.5;
                player.vy = Math.sin(angle) * force * 1.5;
                
                playSound('slash');
            }
        }

        // Mouse Listeners
        window.addEventListener('mousedown', e => startInput(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => moveInput(e.clientX, e.clientY));
        window.addEventListener('mouseup', endInput);

        // Touch Listeners
        window.addEventListener('touchstart', e => {
            startInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling
            moveInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        window.addEventListener('touchend', endInput);

    </script>
</body>
</html>
